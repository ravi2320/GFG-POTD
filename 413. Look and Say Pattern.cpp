/*
Look and Say Pattern
Difficulty: MediumAccuracy: 62.54%Submissions: 40K+Points: 4
Given an integer n. Return the nth row of the following look-and-say pattern.
1
11
21
1211
111221
Look-and-Say Pattern:

To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
1211 is read off as "one 1, one 2, then two 1s" or 111221.
111221 is read off as "three 1s, two 2s, then one 1" or 312211.
Examples:

Input: n = 5
Output: 111221
Explanation: The 5th row of the given pattern will be 111221.
Input: n = 3
Output: 21
Explanation: The 3rd row of the given pattern will be 21.

Constraints:
1 ≤ n ≤ 30
*/

/*
Approach:
- This is a classic simulation problem where we generate the nth term in the "Count and Say" sequence.
- The sequence starts from "1" and each subsequent term is generated by reading the previous term:
  count the number of repeated digits and say the digit.
- For example:
  n = 1: "1"
  n = 2: "11" (one 1)
  n = 3: "21" (two 1s)
  n = 4: "1211" (one 2 one 1)
  and so on.

Intuition:
- We iteratively build the string from 1 to n using a simple parsing loop.
- For each character in the previous term, we count how many times it repeats consecutively and append that count followed by the digit itself.

Time Complexity: O(n * m)
- n is the number of iterations.
- m is the maximum length of the generated string which grows exponentially.
  (Worst case, each digit is unique and string length doubles every step).

Space Complexity: O(m)
- m is the size of the string in the nth term (space for the result).

*/

class Solution {
public:
    string countAndSay(int n) {
        if (n == 1) return "1";  // Base case

        string prev = "1";  // Start with the first term

        // Generate terms from 2 to n
        for (int i = 2; i <= n; i++) {
            string curr = "";  // Store current term
            int cnt = 1;       // Count of current digit

            // Loop through previous string to build the next
            for (int j = 1; j < prev.length(); j++) {
                if (prev[j] == prev[j - 1]) {
                    cnt++;  // Same digit, increase count
                } else {
                    // Append count and digit
                    curr += to_string(cnt) + prev[j - 1];
                    cnt = 1;  // Reset count for new digit
                }
            }

            // Append last group (count and digit)
            curr += to_string(cnt) + prev.back();

            // Update prev to current for next iteration
            prev = curr;
        }

        return prev;  // Final result
    }
};
